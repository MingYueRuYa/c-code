****做linux系统开发，一定要时时站在linux kernel的角度看问题，一定要linux kernel的存在。


一次调用，两次返回的本质？
	linux内核让两个进程，从各自的内存空间返回。
	linux内核fork之后，会产生一个新的进程，这个进程就会放到新的linux内核队列


如何区分返回的是父进程还是子进程？为什么？
	fork()返回的是子进程的id号(大于0), 在父进程中返回的子进程id号是大于0，这样设计是为了父进程可以控制子进程，否则父进程无法确定那个是子进程返回的。同时子进程可以很简单的通过getpid()获取父进程的id号。


关于fork()之后如何确定是子进程还是父进程先返回？
	返回的顺序是有linux kernel决定的。


fork之后子进程copy夫进程的那些资源？
	代码块、堆栈、数据段、进程控制块（PCB），在这里内存四区的概念仍然适用。CPU就是根据PCB来查询进程的状态。


fork之后子进程为什么没有从main函数执行？
	这是因为在fork之前，父进程已经将内存四区初始化了，此时子进程没有必要在从main开始执行，直接从父进程copy就可以了，这样可以提高效率。


进程是对操作系统的资源的抽象，是操作系统调度资源的最小单位。有代码段，数据段，堆栈段和PCB组成。PCB是操作系统感知进程存在的一个重要的数据结构

1.文件锁会copy？
2.文件描述符会copy？
父子进程会共享一个文件描述符


1.linux内核创建0号进程
2.linux内核创建第一个用户进程------->1号进程


写时copy读时共享
	子进程被fork出来之后，并不是马上就会copy父进程的代码段，数据段，堆栈段，PCB等数据，而是在子进程需要进行写数据的时候，才会进行copy，这样做延迟了copy的动作，效率会更高。同时在copy的时候，只copy需要的页内存(页式管理内存)。如果需要的页没有，就会产生软中断，就是页面缺失中断， 进行页copy。如果父进程修改的数据了，操作系统会同时进行页copy，以维护子进程的状态。


在Ubuntu下测试孤儿进程发现
	父进程结束之后，子进程不会托孤给1号init进程，而是托孤给一个user init进程(pid号不是固定的), 而同时user init的父进程是lightdm --session-child，而ligthdm --session-child的父进程是1号进程

C库函数exit()和系统调用_exit()的区别？
	exit()退出时会调用程序终止程序，同时会强制刷新缓冲区的内容，exit()最终会调用_exit()终止程序
	而_exit()直接就陷入到kernel中, 没有调用程序终止函数和刷新缓冲区的内容

wait()和sleep()都是可中断睡眠，同时pause()函数也是一样的
	所以wait在收子进程的时候要判断返回值是不是pid，还是-1(表示可能是由信号惊扰wait)，sleep也是同样的
	在阻塞和接触阻塞的时候，在调用sigprocmask的时候要记住原来的信号集，然后在接触阻塞的时候在设置回去。

 deamon后台服务进程，有以下5个步骤:
	 1.想要fork一个子进程
	 2.父进程exit退出（父进程退出的原因：父进程是一个进程组组长，根据man手册，组长不能调用setsid()）
	 3.新建一个session（新建一个session是为了脱离当前的tty，让程序在后台运行不依赖于任何的tty）
	 4.修改fork子进程的目录为根目录（如果不修改为根目录的话，则当前目录是不能卸载的，如果当前目录没有用的话，应该把它卸载了）
	 5.将标准输入、输出、错误重定向到/dev/null（如果不重定向到/dev/null下的话，deamon可能在标准输出或者其他的输出信息）


可靠信号和非可靠信号的压力测试？
	可靠信号是linux kernel会做8k的缓存，而非可靠信号linux kernel不做缓存，所以后面的都会扔掉

********************在做服务器过程中，一定要时刻记得做压力测试，这样在面试的时候才能做到更好********************

文本处理技巧总结：
	find 命令用于查找符合条件的文件或者目录
	grep 命令对文本模式匹配，按照行的方式
		-v 取反 -n先是匹配的行号 -c只输出匹配的函数
	awk 对文本按照列进行处理和打印
	sort 对文本按照行的方式进行排序处理，默认从小到大的方式
		-n 代表按照数字处理， -k7代表第7列 -r逆序
	sed 命令按照行处理文本
		sed -n "1p" -n按照行打印
		sed -n "1, 3p" 指定范围打印
		sed -n "$p" 最后一行
		sed -n "=" 表示打印行号
		sed 进行文本替换



ipcs
	ipcrm shm id 删除共享内存

socket API
	char *inet_htoa(struct in_addr in) 此函数有点料，值得注意，首先传入的参数不是指针，其二返回的char *，用户却不用释放内存，这样因为临时为返回的char*分配了一个临时的静态区域，但是一定要注意，每次调用的时候这个临时静态区域都会被重写，所以说可能调用这个函数几次可能发现每次的ip地址都是一样的，这时就要注意每次调用的时候指向的地址是相同的



为什么单进程的程序不能做做到多客户端链接？
	这是因为server端一旦进行listen之后就由主动socket变为被动socket。tcp/ip协议栈会为server端维护两个队列，一个是正在进行三次握手和一个已经进行过三次的队列，每次有client连接过来时，都会产生一个中断，此时进行过上次握手的队列就会增加一个socket，但是此时server端没有机会去获取这个socket，没有就机会通信。


长连接和短连接
	长连接可以间断的发送多个包，而不关闭socket连接，例如浏览器请求，http协议就是在TCP/IP协议的基础上衍生的。
	短连接就是每发送一个包，就关闭连接，适用与通信时间短，不经常进行通信的场景。


为什么TCP/IP进行三次握手？以及4次挥手？
	因为TCP/IP是全双工通信，所以要相互确认身份A发送一个包给B，B收到确认之后在发送一个包给A，说明A发送的包B已经收到了，此时A在发送一个包给B，B此时就知道A已经收到B的包，此时双方的通行ESTABLISHED。银行的之间通行确认也是类似这样的思想。
	进行三次握手是因为用最小的代价确认双方身份，可以使用4次握手但是会浪费资源。	


socket中close和shutdown的区别？
	close采用引用计数技术，只要计数没有等于0，文件就不会真的关闭。shutdown可以关闭读或者关闭写，也可以同时关闭读写，shutdown直接就将文件关闭了，文件是真的关闭了。


5中IO模型？
	1.阻塞IO
	2.非阻塞IO --> 轮询方式，让CPU空忙
	----------------------------------
	上面两种都是极端的方式，效率比较低
	----------------------------------
	3.复用IO
		linux kernel支持的select模型，管理所有的IO，有IO发生变化在通知上层的应用，select也会阻塞当前的应用。
	4.信号驱动IO
		有数据来了，就产生信号，去通知上层的应用（因为是不可靠信号，所以可能会发生信号丢失问题），简称为推模式
	5.异步IO
		上层引用分配内存传递给kernel，如果有数据来了，kernel会将数据从kernel空间复制到user空间，并告诉应用数据来了。这样在等待的过程中，应用可以处理其他事件，不会阻塞应用。


TCP/IP的11种状态的转换？


对connect_timeout函数的解释：
1.tcp/ip 在客户端链接服务器的时候，如果异常，connect(默认是阻塞的情况下)，返回时间1.5RTT，大约是75s以上，会造成软件质量的严重下降。
2.sockfd变成非阻塞。
	县试着调用connect。
	如果网络好，马上建立链接
	如果网络不好，则根据返回值
		if (ret < 0 && errno == EINPROGRESS) 表示客户端和服务器段正在建立链接
		我们在等一等，等待的时间我们自己可以控制，把select思想用上
3.注意一点
	select机制监控到conn可读，并不能代表链接是可用的
	还需要进一步的判断(造成可读的几种结果，1 真正的建立链接，2 建立的时候失败，(失败回写错误信息，造成可读))
	int sockoptret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &socklen);
	可以的到错误的信息
		

