做linux系统开发，一定要时时站在linux kernel的角度看问题，一定要linux kernel的存在。


一次调用，两次返回的本质？
	linux内核让两个进程，从各自的内存空间返回。
	linux内核fork之后，会产生一个新的进程，这个进程就会放到新的linux内核队列

`

如何区分返回的是父进程还是子进程？为什么？
	fork()返回的是子进程的id号(大于0), 在父进程中返回的子进程id号是大于0，这样设计是为了父进程可以控制子进程，否则父进程无法确定那个是子进程返回的。同时子进程可以很简单的通过getpid()获取父进程的id号。

关于fork()之后如何确定是子进程还是父进程先返回？
	返回的顺序是有linux kernel决定的。

fork之后子进程copy夫进程的那些资源？
	代码块、堆栈、数据段、进程控制块（PCB），在这里内存四区的概念仍然适用。CPU就是根据PCB来查询进程的状态。

fork之后子进程为什么没有从main函数执行？
	这是因为在fork之前，父进程已经将内存四区初始化了，此时子进程没有必要在从main开始执行，直接从父进程copy就可以了，这样可以提高效率。


进程是对操作系统的资源的抽象，是操作系统调度资源的最小单位。有代码段，数据段，堆栈段和PCB组成。PCB是操作系统感知进程存在的一个重要的数据结构

1.文件锁会copy？
2.文件描述符会copy？


1.linux内核创建0号进程
2.linux内核创建第一个用户进程------->1号进程
