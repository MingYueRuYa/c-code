****做linux系统开发，一定要时时站在linux kernel的角度看问题，一定要linux kernel的存在。


一次调用，两次返回的本质？
	linux内核让两个进程，从各自的内存空间返回。
	linux内核fork之后，会产生一个新的进程，这个进程就会放到新的linux内核队列


如何区分返回的是父进程还是子进程？为什么？
	fork()返回的是子进程的id号(大于0), 在父进程中返回的子进程id号是大于0，这样设计是为了父进程可以控制子进程，否则父进程无法确定那个是子进程返回的。同时子进程可以很简单的通过getpid()获取父进程的id号。


关于fork()之后如何确定是子进程还是父进程先返回？
	返回的顺序是有linux kernel决定的。


fork之后子进程copy夫进程的那些资源？
	代码块、堆栈、数据段、进程控制块（PCB），在这里内存四区的概念仍然适用。CPU就是根据PCB来查询进程的状态。


fork之后子进程为什么没有从main函数执行？
	这是因为在fork之前，父进程已经将内存四区初始化了，此时子进程没有必要在从main开始执行，直接从父进程copy就可以了，这样可以提高效率。


进程是对操作系统的资源的抽象，是操作系统调度资源的最小单位。有代码段，数据段，堆栈段和PCB组成。PCB是操作系统感知进程存在的一个重要的数据结构

1.文件锁会copy？
2.文件描述符会copy？


1.linux内核创建0号进程
2.linux内核创建第一个用户进程------->1号进程


写时copy读时共享
	子进程被fork出来之后，并不是马上就会copy父进程的代码段，数据段，堆栈段，PCB等数据，而是在子进程需要进行写数据的时候，才会进行copy，这样做延迟了copy的动作，效率会更高。同时在copy的时候，只copy需要的页内存(页式管理内存)。如果需要的页没有，就会产生软中断，就是页面缺失中断， 进行页copy。如果父进程修改的数据了，操作系统会同时进行页copy，以维护子进程的状态。


在Ubuntu下测试孤儿进程发现
	父进程结束之后，子进程不会托孤给1号init进程，而是托孤给一个user init进程(pid号不是固定的), 而同时user init的父进程是lightdm --session-child，而ligthdm --session-child的父进程是1号进程

C库函数exit()和系统调用_exit()的区别？
	exit()退出时会调用程序终止程序，同时会强制刷新缓冲区的内容，exit()最终会调用_exit()终止程序
	而_exit()直接就陷入到kernel中, 没有调用程序终止函数和刷新缓冲区的内容

wait()和sleep()都是可中断睡眠
	所以wait在收子进程的时候要判断返回值是不是pid，还是-1(表示可能是由信号惊扰wait)，sleep也是同样的



 deamon后台服务进程，有以下5个步骤:
 1.想要fork一个子进程
 2.父进程exit退出（父进程退出的原因：父进程是一个进程组组长，根据man手册，组长不能调用setsid()）
 3.新建一个session（新建一个session是为了脱离当前的tty，让程序在后台运行不依赖于任何的tty）
 4.修改fork子进程的目录为根目录（如果不修改为根目录的话，则当前目录是不能卸载的，如果当前目录没有用的话，应该把它卸载了）
 5.将标准输入、输出、错误重定向到/dev/null（如果不重定向到/dev/null下的话，deamon可能在标准输出或者其他的输出信息）
