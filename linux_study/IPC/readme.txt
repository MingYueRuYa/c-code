第一章：
    进程同步与进程互斥
    进程间通信目的
    进程间通信进展
    进程间通信分类
    进程间共享信息的三种方式
    IPC对象的持续性 

顺序程序与并发程序特征
顺序程序特征:
    顺序性
    封闭性：（运行环境的封闭性） 
    确定性
    可再现性

并发程序特征：
    共享性
    并发性
    随机性

进程互斥：
    由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间竞争使用这些
    资源，进程的这种关系为互斥

    临界或互斥资源：一个只允许一个进程使用
    
    临界区：涉及到互斥资源的程序段

进程同步：
    多个进程需要相互配合共同完成一项任务

进程间通信的目的：
    1.数据传输，一个进程需要将它的数据发送另外一个进程
    2.资源共享：多个进程之间共享同样的资源
    3.通知事件：一个进程需要向一个进程或一组进程发送消息，通知他们发生了某
    种时间（如进程终止时要通知父进程）
    4.进程控制：有些进程希望完全控制另一个进程的执行（debug进程），此时控制
    进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态

进程间通信分类：
1.文件
2.文件锁
3.（管道）pipe和（有名管道）FIFO
4.信号（signal）
5.消息共享
6.共享内存
7.信号量
8.互斥量
9.条件变量
10.读写锁
11套接字（socket）

//分类：锁，管道，信号，消息队列，共享内存，socket，3个量

System V IPC
    消息队列
    共享内存
    信号量 

POSIX IPC
    消息队列
    共享内存
    信号量
    互斥量
    条件变量
    读写锁

IPC对象的持续性3种
    用户空间：效率较高
    随进程持续：一直存在知道打开的最有一个进程结束（pipe和FIFO）
    
    内核共享：
    随内核持续：一直存在直到内核自举或显式删除（System V消息队列、
        共享内存、信号量）

    文件系统共享：
    随文件系统:一直存在直到显式删除，即使内核自举还存在（POSIX消息队列、
        共享内存、信号量如果是使用映射文件来实现）

第二章：
死锁：
信号量与PV原语
用PV原语解决司机与售票员的问题
用PV原语解决民航售票问题
用PV原语解决汽车租赁问题 

互斥：人与人之间的矛盾关系
同步：人与人之间的协作关系

死锁：
    多个进程之间相互等待对方的资源，而在得到对方的资源之前也不释放自己的资源  
    ，就造成循环等待的现象。如果所有进程都在等待一个不可能发生的事，则死锁
进程死锁的必要条件：
    1.互斥条件
        进程对资源进行排他性使用，在一段时间内某资源仅为一个进程所占用
    2.请求和保持条件
        当进程因为资源而阻塞时，手中的资源也不会释放
    3.不可剥夺条件
        进程的资源不能被剥夺，只能使用完成自己释放 
    4.环路等待条件
        各个进程组成封闭的环形链，每个进程都在等待下一个进程所占用的资源

防止死锁的办法：破坏2-4中的3个条件
资源一次性分配: 破坏请求和保持条件
可剥夺资源：破坏不可剥夺条件
资源有序分配法：破坏循环等待条件

死锁避免：
预防死锁的几种策略，会严重的损坏系统性能，因此在避免死锁时，要施加较弱的限制
，从而获得较满意的系统性能
由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前
预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配
给进程；否则，进程等待。其中最具有代表性的避免死锁算法就是银行家算法

信号量和P、V原语有Dijkstra(迪杰斯特拉)提出
信号量：
    互斥：P、V在同一个进程中
    同步：P、V在不同进程中

信号量值含义：
    S>0:    S表示可用资源的个数
    S=0：   表示无可用资源，无等待进程
    S<0:    |S|表示等待队列中进程个数

struct semaphore
{
    int value;
    pointer_PCB queue;
}


P,V都是原子性操作
P原语
P(S)
{
    s.value = s.value--;
    if (s.value < 0) {
        该进程状态置为等待状态
        将该进程的PCB插入相应的等待队列s.queue
    }
}

V(S)
{
    s.value++;
    if (s.value <= 0) {
        唤醒等待队列中的进程，将其插入到就绪队列中
    }
}

PV原语解决司机与售票员问题
司机进程：              售票员进程：
   S1(0)                S2(0)

   while(1) {           while(1) {
    P(S1)               关门
    启动车辆            V(S1) 
    正常运行            售票 
    到站停车            P(S2) 
    V(S2)               开门 
}                     }

PV原语解决民航售票问题
    票数=x
    S(1)

    P(S)
    if (x > 0)
        x--
    V(S)

PV原语解决汽车租赁问题
    S(2)
    P(S)
    租车
    还车
    V(S)



System V 消息队列
IPC对象数据结构
消息队列结构
消息队列在内核中表示
消息队列的函数

共享内存
    共享内存是最快的IPC形式。一旦这样的内存映射到共享它的进程地址空间，这些数据
    传递不再涉及到内核，换句说是进程不再通过执行进入内核的系统调用来传递彼此数
    据
共享内存示意图
管道、消息队列与共享内存传递数据对比
mmap函数
munmap函数
msync函数


程序：完成特定功能的一系列有序指令的集合
可执行文件
代码段+数据段

进程：程序的一次动态执行过程
代码段+数据段+堆栈端+PCB

进程            程序
动态的          数据端
短暂的          永久的
堆栈端+PCB

一个进程只能对应一个程序
一个程序可以对应多个进程

进程是分配资源的基本单位
线程是程序执行的最小单位

线程共享进程数据，但也拥有自己的数据
1.线程ID
2.一组寄存器
3.栈
4.errno
5.信号状态
6.优先级

共享的：
UID，GID，EGID，CWD
signal dispatch table
memory map
file descriptors

线程调度竞争范围
进程内
系统内



